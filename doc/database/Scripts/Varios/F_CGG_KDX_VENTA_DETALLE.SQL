/**
 * FUNCION SII.F_CGG_KDX_VENTA_DETALLE_REGISTRO
 * SELECCIONA N REGISTROS DE LA TABLA SII.CGG_KDX_ASIGNACION.
 * @param IN_USER_NAME NOMBRE DE USUARIO DEL SERVIDOR DE APP. O DE LA BASE DE DATOS
 * @param IN_AMBITO AMBITO
 * @param IN_CKESP_CODIGO CODIGO DE IDENTIFICACION UNICO DE REGISTRO DE ESPECIE
 * @param IN_CTREG_CODIGO CODIGO DE IDENTIFICACION UNICO DE REGISTRO DE TCT
 * @return VARCHAR
 */
CREATE OR REPLACE FUNCTION SII.F_CGG_KDX_VENTA_DETALLE_REGISTRO(
IN IN_USER_NAME VARCHAR,
IN IN_AMBITO INT,
IN IN_CKESP_CODIGO SII.CGG_KDX_VENTA_DETALLE.CKESP_CODIGO%TYPE,
IN IN_CTREG_CODIGO VARCHAR
)RETURNS VARCHAR AS
$$
DECLARE
	TMP_CKVNT_CODIGO VARCHAR DEFAULT NULL;
	TMP_CKVNT_CODIGO2 VARCHAR DEFAULT NULL;
	TMP_CKASG_CODIGO VARCHAR DEFAULT NULL;
	TMP_CKUPV_CODIGO VARCHAR[];
	TMP_RES BOOLEAN DEFAULT FALSE;
	TMP_ARRAY  VARCHAR[];
	CONTADOR INTEGER DEFAULT 1;
	TMP_PRECIO_UNITARIO NUMERIC;
	TMP_VENTA_DETALLE VARCHAR;
	TMP_CKVDT_CODIGO VARCHAR;
	TMP_CTREG_CODIGO VARCHAR;
	TMP_CRCNT_CODIGO VARCHAR;
	TMP_CTIGF_CODIGO VARCHAR;
	TMP_RESULTADO VARCHAR;
	TMP_CANTIDAD INTEGER DEFAULT 1;--VARIABLE UTILIZADA PARA ALMACENAR LA CANTIDAD DE ESPECIES A UTILIZAR
BEGIN
--SELECCION DEL USUARIO POR PUNTO DE VENTA
	SELECT ARRAY(SELECT CKUPV_CODIGO FROM SII.CGG_KDX_USUARIO_PV 
			WHERE CKPVT_CODIGO =(
			SELECT CKPVT_CODIGO FROM SII.CGG_KDX_USUARIO_PV UPV1
			INNER JOIN CGG_USUARIO CUSU ON (UPV1.CUSU_CODIGO  = CUSU.CUSU_CODIGO )
			WHERE CUSU_NOMBRE_USUARIO = IN_USER_NAME
				AND UPV1.CKUPV_ESTADO = TRUE
				AND UPV1.CKPVT_ACTIVO = TRUE
			) AND CKUPV_ESTADO = TRUE) INTO TMP_CKUPV_CODIGO;

	/*SELECT CKUPV_CODIGO INTO TMP_CKUPV_CODIGO
	FROM SII.CGG_KDX_USUARIO_PV UPV1
	INNER JOIN CGG_USUARIO CUSU ON
		(UPV1.CUSU_CODIGO  = CUSU.CUSU_CODIGO )
	WHERE CUSU_NOMBRE_USUARIO = IN_USER_NAME
		AND UPV1.CKUPV_ESTADO = TRUE
		AND UPV1.CKPVT_ACTIVO = TRUE;*/
	--VERIFICA SI EL TIPO DE OPERACION ES PARA FORMULARIOS SIN VALOR
	--0 RESIDENCIA, 1 ESPECIES VALORADAS TCT, 2 FORMULARIOS SIN VALOR
	IF IN_AMBITO = 2 THEN
		TMP_CANTIDAD := 3;
	END IF;
--SELECCION DE LA ASIGNACION DISPONIBLE PARA EL REGISTRO DE LA VENTA
	SELECT CKASG.CKASG_CODIGO INTO TMP_CKASG_CODIGO
		FROM SII.CGG_KDX_ASIGNACION  CKASG
		INNER JOIN CGG_KDX_TRANSFERENCIA CKTRN ON
				(CKTRN.CKTRN_CODIGO = CKASG.CKTRN_CODIGO)
			WHERE CKASG_ESTADO_ASIGNACION = 0
			AND CKASG.CGG_CKUPV_CODIGO = ANY(TMP_CKUPV_CODIGO)
			AND CKASG.CKASG_CANTIDAD_DISPONIBLE >= TMP_CANTIDAD
			AND CKASG.CKASG_ESTADO = TRUE
			AND CKTRN.CKESP_CODIGO = IN_CKESP_CODIGO
	ORDER BY CKASG.CKASG_FECHA_RECEPCION,CKASG.CKASG_CODIGO ASC
	LIMIT 1;
--SELECCION Y COMPROBACION DE LA EXISTENCIA DE REGISTRO DE VENTA POR EL USUARIO ACTUAL
	SELECT CKVNT.CKVNT_CODIGO INTO TMP_CKVNT_CODIGO
	FROM SII.CGG_KDX_VENTA CKVNT
	INNER JOIN CGG_KDX_VENTA_DETALLE CKVDT  ON
		(CKVDT.CKVNT_CODIGO = CKVNT.CKVNT_CODIGO)
	WHERE DATE(CKVNT.CKVNT_FECHA_INGRESO) = CURRENT_DATE
	AND CKVNT.CKASG_CODIGO = TMP_CKASG_CODIGO
	AND CKVNT_ESTADO_VENTA = 0 --CONTROL AGREGADO PARA COMPROBACION DE QUE SOLO SE REGISTREN VENTAS QUE NO HAYAN SIDO CONTABILIZADAS
	AND CKVNT.CKVNT_ESTADO = TRUE ;
	
	
	--SELLECION DEL VALOR DE VENTA DE LA ESPECIE
	SELECT CKTRN.CKTRN_PRECIO_UNITARIO INTO TMP_PRECIO_UNITARIO FROM CGG_KDX_ASIGNACION  CKASG
		INNER JOIN CGG_KDX_TRANSFERENCIA CKTRN ON (CKTRN.CKTRN_CODIGO = CKASG.CKTRN_CODIGO)
		WHERE CKASG.CKASG_CODIGO = TMP_CKASG_CODIGO;
	--CUANDO NO EXISTE UN REGISTRO DE VENTA QUE CUMPLA LAS CONDICIONES  SE CREA UNO NUEVO
	IF TMP_CKVNT_CODIGO IS NULL THEN 
		IF TMP_CKASG_CODIGO IS NOT NULL THEN 
			--INSERCION DE LA CABECERA DE LA VENTA				
			TMP_CKVNT_CODIGO := SII.F_CGG_KDX_VENTA_INSERT(
				'KEYGEN'::VARCHAR,
				TMP_CKASG_CODIGO::VARCHAR,
				0,
				CURRENT_TIMESTAMP,
				'0',
				0,
				0,
				1::smallint,
				TMP_PRECIO_UNITARIO::VARCHAR,
				0::smallint,--ESTADO DE LA VENTA DEFAULT REGISTRADA
				TRUE,
				IN_USER_NAME
			);
		ELSE
			RAISE EXCEPTION 'El usuario no tiene asignado los tipos de especies requeridos ';--RETURN FALSE::VARCHAR;
		END IF;
	ELSE --CASO CONTRARIO  SE ACTUALIZA LA CANTIDAD DE ESPECIES VENDIDAS
		UPDATE SII.CGG_KDX_VENTA SET CKVNT_CANTIDAD = CKVNT_CANTIDAD + TMP_CANTIDAD,
			CKVNT_TOTAL = (CKVNT_CANTIDAD + TMP_CANTIDAD) * TMP_PRECIO_UNITARIO
		WHERE CKVNT_CODIGO = TMP_CKVNT_CODIGO;
	END IF;
	
	TMP_ARRAY := string_to_array(IN_CTREG_CODIGO, ',');
	--INSERCION DEL DETALLE DE LA VENTA TENTATIVO ENVIO DE UNA CADENA SEPARA POR COMAS EJEMPLO (1,2,3,4)
	 WHILE CONTADOR <= array_length(TMP_ARRAY,1) LOOP
		--SELECCIONA EL CODIGO DE VENTA DETALLE SI YA EXISTE Y TAMBIEN LA VENTA PARA SU COMPROBACION
		CASE WHEN IN_AMBITO = 0 THEN
			TMP_CRCNT_CODIGO := TMP_ARRAY[CONTADOR];
			SELECT CKVDT_CODIGO,CKVNT_CODIGO INTO TMP_CKVDT_CODIGO,TMP_CKVNT_CODIGO2 
			FROM SII.CGG_KDX_VENTA_DETALLE 
			WHERE CRCNT_CODIGO = TMP_ARRAY[CONTADOR] ORDER BY CKVDT_FECHA_UPDATE DESC LIMIT 1;
			UPDATE CGG_RES_CARNET SET CRCNT_CARNET_IMPRESO = TRUE WHERE CRCNT_CODIGO = TMP_CRCNT_CODIGO;
			--ACTUALIZACION DEL ESTADO DE DE IMPRESION DEL CARNET
		--ESPECIES DE RESIDENCIA
		WHEN IN_AMBITO = 1 THEN
			TMP_CTREG_CODIGO := TMP_ARRAY[CONTADOR];
			SELECT CKVDT_CODIGO,CKVNT_CODIGO INTO TMP_CKVDT_CODIGO,TMP_CKVNT_CODIGO2 
			FROM SII.CGG_KDX_VENTA_DETALLE 
			WHERE CTREG_CODIGO = TMP_ARRAY[CONTADOR] ORDER BY CKVDT_FECHA_UPDATE DESC LIMIT 1;
		--ESPECIES NO VALORADAS PARA INTENTOS FALLIDOS
		WHEN IN_AMBITO = 2 THEN
			TMP_CTIGF_CODIGO := TMP_ARRAY[CONTADOR];
			SELECT CKVDT_CODIGO,CKVNT_CODIGO INTO TMP_CKVDT_CODIGO,TMP_CKVNT_CODIGO2 
			FROM SII.CGG_KDX_VENTA_DETALLE 
			WHERE CTIGF_CODIGO = TMP_ARRAY[CONTADOR] ORDER BY CKVDT_FECHA_UPDATE DESC LIMIT 1;
		END CASE;
		--SI EL DETALLE YA ESTA LIGADO CON UNA VENTA CREA UN NUEVO REGISTRO CASO CONTRARIO LO ACTUALIZA
		IF  TMP_CKVNT_CODIGO2 IS NULL AND TMP_CKVDT_CODIGO IS NOT NULL THEN
			TMP_VENTA_DETALLE := SII.F_CGG_KDX_VENTA_DETALLE_UPDATE(
				TMP_CKVDT_CODIGO,
				TMP_CKVNT_CODIGO,
				IN_CKESP_CODIGO::VARCHAR,
				TMP_CTREG_CODIGO,
				TMP_CRCNT_CODIGO,
				TMP_CTIGF_CODIGO,
				TMP_CANTIDAD,					
				0,
				TMP_PRECIO_UNITARIO,
				TMP_PRECIO_UNITARIO,
				TRUE,
				IN_USER_NAME
				);		
		ELSE
			TMP_VENTA_DETALLE := SII.F_CGG_KDX_VENTA_DETALLE_INSERT(
				'KEYGEN',
				TMP_CKVNT_CODIGO,
				IN_CKESP_CODIGO::VARCHAR,
				TMP_CTREG_CODIGO,
				TMP_CRCNT_CODIGO,
				TMP_CTIGF_CODIGO,
				TMP_CANTIDAD,					
				0,
				TMP_PRECIO_UNITARIO,
				TMP_PRECIO_UNITARIO,
				TRUE,
				IN_USER_NAME
				);	
		END IF;
		CONTADOR := CONTADOR + 1;
	 END LOOP;
	 --ACTUALIZACION DE CANTIDAD DISPONIBLE EN LA ASIGNACION
	 TMP_CANTIDAD := array_length(TMP_ARRAY,1)*TMP_CANTIDAD;
	 UPDATE SII.CGG_KDX_ASIGNACION 
	 SET CKASG_CANTIDAD_DISPONIBLE =  CKASG_CANTIDAD_DISPONIBLE - TMP_CANTIDAD,
	 CKASG_ESTADO_ASIGNACION = (CASE WHEN (CKASG_CANTIDAD_DISPONIBLE - TMP_CANTIDAD)>0 THEN CKASG_ESTADO_ASIGNACION ELSE 2 END) --ACTUALIZA LA ASIGNACION A ESTADO 3 SI YA NO HAY ESPECIES DISPONIBLES
	 WHERE CKASG_CODIGO = TMP_CKASG_CODIGO;
	--VERIFICACION DEL STOCK DISPONIBLE Y ENVIO DE NOTIFICACION VIA MAIL
	 SELECT SII.F_CGG_KDX_CONTROL_STOCK(
		IN_CKESP_CODIGO,
		TMP_CKASG_CODIGO,
		0,
		IN_USER_NAME
		) INTO TMP_RESULTADO;
	 TMP_RES := TRUE;
RETURN  TMP_RES::VARCHAR;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_CGG_KDX_VENTA_DETALLE_SELECT_GROUP_BY_VENTA
* SELECCIONA UN REGISTRO EN LA TABLA SII.CGG_KDX_VENTA_DETALLE.
* @param IN_CKVNT_CODIGO IDENTIFICATIVO UNICO DE REGISTRO DE LA VENTA 
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_KDX_VENTA_DETALLE_SELECT_GROUP_BY_VENTA(
IN IN_CKVNT_CODIGO SII.CGG_KDX_VENTA_DETALLE.CKVNT_CODIGO%TYPE
)RETURNS SETOF REFCURSOR AS
$$
DECLARE
	TMP_REF REFCURSOR;
BEGIN
	OPEN TMP_REF FOR
		SELECT CKVNT_CODIGO,
			CKVDT_PRECIO_UNITARIO,
			CKVDT.CKESP_CODIGO,
			(SELECT CKESP.CKESP_NOMBRE 
			FROM CGG_KDX_ESPECIE CKESP
			WHERE CKESP.CKESP_CODIGO = CKVDT.CKESP_CODIGO) CKESP_NOMBRE,
			SUM(CKVDT_CANTIDAD) CKVDT_CANTIDAD,
			SUM(CKVDT_TOTAL) CKVDT_TOTAL
		FROM CGG_KDX_VENTA_DETALLE CKVDT
		WHERE CKVNT_CODIGO = IN_CKVNT_CODIGO
		AND CKVDT_ESTADO = TRUE
		GROUP BY CKVNT_CODIGO,CKVDT_PRECIO_UNITARIO,CKESP_CODIGO;
	RETURN NEXT TMP_REF;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_CGG_KDX_CONTROL_STOCK
* SELECCIONA UN REGISTRO EN LA TABLA SII.CGG_KDX_VENTA_DETALLE.
* @param IN_CKVNT_CODIGO IDENTIFICATIVO UNICO DE REGISTRO DE LA VENTA 
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_KDX_CONTROL_STOCK(
IN IN_CKESP_CODIGO SII.CGG_KDX_ESPECIE.CKESP_CODIGO%TYPE,
IN IN_CODIGO_CONTROL VARCHAR,
IN IN_TIPO_CONTROL INTEGER,
IN IN_USER_NAME VARCHAR
)RETURNS VOID AS
$$
DECLARE
	TMP_STOCK_MINIMO NUMERIC;
	TMP_STOCK_DISPONIBLE NUMERIC;
	TMP_CKESP_NOMBRE VARCHAR;
	TMP_REF REFCURSOR;
	TMP_ASUNTO VARCHAR;
	TMP_MENSAJE VARCHAR;
	TMP_NOMBRE_PERSONA VARCHAR;
	TMP_CUSU_CODIGO VARCHAR;
	TMP_RETURN_CODIGO VARCHAR;
	TMP_EMAIL RECORD;
BEGIN
	SELECT CKESP_DISPONIBLE_MIN,CKESP_NOMBRE INTO TMP_STOCK_MINIMO,TMP_CKESP_NOMBRE
	FROM CGG_KDX_ESPECIE
	WHERE CKESP_CODIGO = IN_CKESP_CODIGO;
	CASE IN_TIPO_CONTROL 
	WHEN 0 THEN
		SELECT CKASG_CANTIDAD_DISPONIBLE  INTO TMP_STOCK_DISPONIBLE  FROM CGG_KDX_ASIGNACION WHERE CKASG_CODIGO = IN_CODIGO_CONTROL; 
		
		IF TMP_STOCK_DISPONIBLE <= TMP_STOCK_MINIMO THEN		
		
			/*SELECT UPV.CUSU_CODIGO INTO TMP_CUSU_CODIGO FROM CGG_KDX_ASIGNACION ASG
			INNER JOIN CGG_KDX_TRANSFERENCIA TRN ON (ASG.CKTRN_CODIGO = TRN.CKTRN_CODIGO)
			INNER JOIN CGG_KDX_PUNTO_VENTA PVT ON (TRN.CKPVT_CODIGO = PVT.CKPVT_CODIGO)
			INNER JOIN CGG_KDX_USUARIO_PV UPV ON (UPV.CKPVT_CODIGO = PVT.CKPVT_CODIGO) 
			WHERE  UPV.CKUPV_SUPERVISOR
			AND ASG.CKASG_CODIGO = IN_CODIGO_CONTROL 
			LIMIT 1;*/
			SELECT UPV.CUSU_CODIGO  INTO TMP_CUSU_CODIGO FROM CGG_KDX_ASIGNACION ASG
			INNER JOIN CGG_KDX_USUARIO_PV UPV ON (UPV.CKUPV_CODIGO = ASG.CGG_CKUPV_CODIGO) 
			WHERE  ASG.CKASG_CODIGO = IN_CODIGO_CONTROL;

			SELECT SII.F_CUSU_NOMBRE_PERSONA(TMP_CUSU_CODIGO,0) INTO TMP_NOMBRE_PERSONA;
			--Candidato seleccionado para la entrevista
			
				TMP_ASUNTO := 'Notificacion: Control de stock.';
				TMP_MENSAJE := 'Estimad@ '||TMP_NOMBRE_PERSONA||':<br/>'||
					'<BR/>Le comunicamos que el stock de las especies <b>'||TMP_CKESP_NOMBRE||' </b> esta proximo a agotarse.<br/>'					
					'<br/><b>Stock actual:</b> '|| TMP_STOCK_DISPONIBLE||
					'<br/><b>Minimo sugerido:</b> '||TMP_STOCK_MINIMO||
					'<br/><br/>Por favor pongase en contacto con el encargado de sus provisiones para evitar contratiempos. ';
			
			FOR TMP_EMAIL IN 
				(SELECT UCN.CSUCT_CONTACTO FROM CGG_USUARIO US
				INNER JOIN SII.CGG_SEC_USUARIO_CONTACTO UCN ON UCN.CUSU_CODIGO = US.CUSU_CODIGO
				WHERE US.CUSU_CODIGO = TMP_CUSU_CODIGO AND UCN.CRTCO_CODIGO = (SELECT CGCNF_VALOR_CADENA FROM SII.CGG_CONFIGURACION WHERE CGCNF_CODIGO = 'CONF43'))		
			LOOP
				SELECT SII.F_CGG_BUZON_CORREO_INSERT(
					'KEYGEN'::VARCHAR,		
					TMP_EMAIL.CSUCT_CONTACTO, 
					TMP_ASUNTO, 
					TMP_MENSAJE, 
					'text/html'::VARCHAR, 
					0, 
					FALSE, 
					TRUE, 
					IN_USER_NAME				
				) INTO TMP_RETURN_CODIGO;
			END LOOP;		
		
		  
		END IF;
	WHEN 1 THEN
		SELECT CKTRN_CANTIDAD_DISPONIBLE INTO TMP_STOCK_DISPONIBLE FROM CGG_KDX_TRANSFERENCIA WHERE CKPVT_CODIGO = IN_CODIGO_CONTROL;
		IF TMP_STOCK_DISPONIBLE <= TMP_STOCK_MINIMO THEN		
		
			SELECT UPV.CUSU_CODIGO INTO TMP_CUSU_CODIGO 
			FROM CGG_KDX_TRANSFERENCIA TRN 
			INNER JOIN CGG_KDX_PUNTO_VENTA PVT ON (TRN.CKPVT_CODIGO = PVT.CKPVT_CODIGO)
			INNER JOIN CGG_KDX_USUARIO_PV UPV ON (UPV.CKPVT_CODIGO = PVT.CKPVT_CODIGO) 
			WHERE  UPV.CKUPV_SUPERVISOR
			AND TRN.CKTRN_CODIGO = IN_CODIGO_CONTROL 
			LIMIT 1;
			

			SELECT SII.F_CUSU_NOMBRE_PERSONA(TMP_CUSU_CODIGO,0) INTO TMP_NOMBRE_PERSONA;
			--Candidato seleccionado para la entrevista
			
				TMP_ASUNTO := 'Notificacion: Control de stock.';
				TMP_MENSAJE := 'Estimad@ '||TMP_NOMBRE_PERSONA||':<br/>'||
					'<BR/>Le comunicamos que el stock de las especies <b>'||TMP_CKESP_NOMBRE||' </b> esta proximo a agotarse.<br/>'					
					'<br/><b>Stock actual:</b> '|| TMP_STOCK_DISPONIBLE||
					'<br/><b>Minimo sugerido:</b> '||TMP_STOCK_MINIMO||
					'<br/><br/>Por favor pongase en contacto con el encargado de sus provisiones para evitar contratiempos. ';
			
			FOR TMP_EMAIL IN 
				(SELECT UCN.CSUCT_CONTACTO FROM CGG_USUARIO US
				INNER JOIN SII.CGG_SEC_USUARIO_CONTACTO UCN ON UCN.CUSU_CODIGO = US.CUSU_CODIGO
				WHERE US.CUSU_CODIGO = TMP_CUSU_CODIGO AND UCN.CRTCO_CODIGO = (SELECT CGCNF_VALOR_CADENA FROM SII.CGG_CONFIGURACION WHERE CGCNF_CODIGO = 'CONF43'))		
			LOOP
				SELECT SII.F_CGG_BUZON_CORREO_INSERT(
					'KEYGEN'::VARCHAR,		
					TMP_EMAIL.CSUCT_CONTACTO, 
					TMP_ASUNTO, 
					TMP_MENSAJE, 
					'text/html'::VARCHAR, 
					0, 
					FALSE, 
					TRUE, 
					IN_USER_NAME				
				) INTO TMP_RETURN_CODIGO;
			END LOOP;		
		
		  
		END IF;
	ELSE
		SELECT  CKKRD_TOTAL_CANTIDAD INTO TMP_STOCK_DISPONIBLE FROM CGG_KDX_KARDEX WHERE CKESP_CODIGO = IN_CODIGO_CONTROL ORDER BY CKKRD_NUMERO DESC LIMIT 1;
	END CASE;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;



/**
* FUNCION SII.F_CGG_KDX_CONTROL_SERIES
* VERIFICA SI LA SERIE INGRESADA PARA LA OPERACION ES VALIDA.
* @param IN_CKESP_CODIGO IDENTIFICATIVO UNICO DE REGISTRO DE ESPECIE
* @param IN_TIPO_CONTROL IDENTIFICATIVO DE CONTROL 0 TRANSFERENCIA, 1 ASIGNACIONES 
* @param IN_SERIE_INICIO SERIE DE INICIO
* @param IN_SERIE_FIN SERIE FIN
* @return VARCHAR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_KDX_CONTROL_SERIES(
IN IN_CKESP_CODIGO SII.CGG_KDX_ESPECIE.CKESP_CODIGO%TYPE,
IN IN_TIPO_CONTROL INTEGER,
IN IN_SERIE_INICIO INTEGER,
IN IN_SERIE_FIN INTEGER
)RETURNS VARCHAR AS
$$
DECLARE
	TMP_SERIE_MAX INTEGER;
	TMP_STOCK_MINIMO INTEGER;
	TMP_CKESP_NOMBRE VARCHAR;
	TMP_REF REFCURSOR;
	TMP_RECORD RECORD;
	TMP_RECORD1 RECORD;
	TMP_SERIE_INICIO INTEGER;
	TMP_SERIE_FIN INTEGER;
	TMP_IS_CONTENT BOOLEAN DEFAULT FALSE;
BEGIN
	CASE
	WHEN  IN_TIPO_CONTROL  = 0 THEN
			/*SELECT MAX(CKTRN_SERIE_FIN) INTO  TMP_SERIE_MAX
				FROM CGG_KDX_TRANSFERENCIA
				WHERE CKESP_CODIGO = IN_CKESP_CODIGO
				AND CKTRN_ESTADO;*/			

			FOR TMP_RECORD IN 
				SELECT CKTRN_CODIGO,CKTRN_SERIE_INICIO,CKTRN_SERIE_FIN 
				FROM CGG_KDX_TRANSFERENCIA
				WHERE CKESP_CODIGO = IN_CKESP_CODIGO
				AND CKTRN_ESTADO
				ORDER BY CKTRN_SERIE_INICIO ASC		
			LOOP
				TMP_SERIE_INICIO := TMP_RECORD.CKTRN_SERIE_INICIO ;
				TMP_SERIE_FIN := TMP_RECORD.CKTRN_SERIE_FIN ;				
				IF(TMP_IS_CONTENT = FALSE) THEN
					IF (IN_SERIE_INICIO BETWEEN TMP_RECORD.CKTRN_SERIE_INICIO AND TMP_RECORD.CKTRN_SERIE_FIN)  OR (IN_SERIE_FIN BETWEEN TMP_RECORD.CKTRN_SERIE_INICIO AND TMP_RECORD.CKTRN_SERIE_FIN) THEN
						TMP_IS_CONTENT := TRUE;
					ELSE
						IF(IN_SERIE_INICIO < TMP_SERIE_INICIO AND IN_SERIE_FIN < TMP_SERIE_INICIO) 
							OR(IN_SERIE_INICIO > TMP_SERIE_FIN AND IN_SERIE_FIN > TMP_SERIE_FIN) THEN
							TMP_IS_CONTENT := FALSE;
						ELSE
							TMP_IS_CONTENT := TRUE;
						END IF;
					END IF;	
				END IF;				
			END LOOP;		
			
		  
	WHEN  IN_TIPO_CONTROL  = 1 THEN
			SELECT MAX(CKASG_SERIE_FIN) INTO  TMP_SERIE_MAX 
			FROM CGG_KDX_ASIGNACION A
			INNER JOIN CGG_KDX_TRANSFERENCIA T ON (A.CKTRN_CODIGO = T.CKTRN_CODIGO)
			WHERE CKESP_CODIGO = IN_CKESP_CODIGO
			AND CKASG_ESTADO;

			FOR TMP_RECORD IN 
				SELECT CKASG_CODIGO,CKASG_SERIE_INICIO,CKASG_SERIE_FIN 
				FROM CGG_KDX_ASIGNACION A
				INNER JOIN CGG_KDX_TRANSFERENCIA T ON (A.CKTRN_CODIGO = T.CKTRN_CODIGO)
				WHERE CKESP_CODIGO = IN_CKESP_CODIGO
				AND CKASG_ESTADO		
			LOOP
				TMP_SERIE_INICIO := TMP_RECORD.CKASG_SERIE_INICIO ;
				TMP_SERIE_FIN := TMP_RECORD.CKASG_SERIE_FIN ;					
				IF(TMP_IS_CONTENT = FALSE) THEN
					IF (IN_SERIE_INICIO BETWEEN TMP_RECORD.CKASG_SERIE_INICIO AND TMP_RECORD.CKASG_SERIE_FIN)  OR (IN_SERIE_FIN BETWEEN TMP_RECORD.CKASG_SERIE_INICIO AND TMP_RECORD.CKASG_SERIE_FIN)THEN
						TMP_IS_CONTENT := TRUE;
					ELSE
						IF(IN_SERIE_INICIO < TMP_SERIE_INICIO AND IN_SERIE_FIN < TMP_SERIE_INICIO) 
							OR(IN_SERIE_INICIO > TMP_SERIE_FIN AND IN_SERIE_FIN > TMP_SERIE_FIN) THEN
							TMP_IS_CONTENT := FALSE;
						ELSE
							TMP_IS_CONTENT := TRUE;
						END IF;
					END IF;	
				END IF;	
			
			END LOOP;	
			
			
		
	END CASE;
RETURN TMP_IS_CONTENT::VARCHAR;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;