/**
* FUNCION sii.F_KEYGEN
* FUNCION QUE GENERA CLAVES PARA LAS TABLAS DEL ESQUEMA.
* @param INTABLENAME NOMBRE DE LA TABLA QUE REQUIERE LA CLAVE.
* @param INCOLNAME COLUMNA DE LA TABLA QUE REQUIERE LA CLVAE.
* @param INABR ABREVIATURA DEL NOMBRE DE LA TABLA SOLICITANTE.
* @return NUEVA CLAVE GENERADA.
*/
CREATE OR REPLACE FUNCTION sii.F_KEYGEN(
IN INTABLENAME VARCHAR,
IN INCOLNAME VARCHAR,
IN INABR VARCHAR
)RETURNS VARCHAR AS
$$
DECLARE
TMP_NUMREGISTROS NUMERIC;
TMP_EXISTS NUMERIC;
OUT_KEY VARCHAR;
BEGIN
	EXECUTE 'SELECT COUNT('||INCOLNAME||')+1 FROM sii.'||INTABLENAME INTO TMP_NUMREGISTROS;
	OUT_KEY := INABR||TMP_NUMREGISTROS;
	EXECUTE 'SELECT COUNT('||INCOLNAME||') FROM sii.'||INTABLENAME||' WHERE '||INCOLNAME||' = $1' INTO TMP_EXISTS USING OUT_KEY;
	IF (TMP_EXISTS > 0) THEN
		FOR I IN 1..TMP_NUMREGISTROS LOOP
			EXECUTE 'SELECT COUNT('||INCOLNAME||') FROM sii.'||INTABLENAME||' WHERE '||INCOLNAME||' = $1' INTO TMP_EXISTS USING INABR||I;
			IF (TMP_EXISTS = 0) THEN
				OUT_KEY := INABR||I;
				EXIT;
			END IF;
		END LOOP;
	END IF;
	RETURN OUT_KEY;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_STRING_IN
* FUNCION PARA BUSQUEDA DE CADENAS DE TEXTO.
* @param INFINDTEXT CADENA DE TEXTO QUE SE DESEA BUSCAR.
* @param INSOURCETEXT CADENA DE TEXTO EN LA QUE VA A BUSCAR.
* @return 0 SI NO ENCONTRO, CASO CONTRARIO 1.
*/
CREATE OR REPLACE FUNCTION SII.F_STRING_IN(
IN IN_FIND_TEXT TEXT, 
IN IN_SOURCE_TEXT TEXT
)RETURNS INT AS
$$
DECLARE
	TMP_TEXT_ARRAY TEXT[];
	TMP_FT_LENGTH INT;
	I INT;
	OUT_RES INT;
	TMP_SOURCE VARCHAR;
BEGIN
	IF (LENGTH(IN_FIND_TEXT) = 0) THEN
		RETURN 1;
	END IF;
	--IF (SELECT to_tsvector(IN_SOURCE_TEXT) @@ plainto_tsquery(IN_FIND_TEXT)) THEN
	--	RETURN 1;
	--ELSE
	--	RETURN 0;
	--END IF;
	OUT_RES := 1;
	TMP_SOURCE = UPPER(IN_SOURCE_TEXT);
	TMP_TEXT_ARRAY := STRING_TO_ARRAY(UPPER(IN_FIND_TEXT), ' ');
	TMP_FT_LENGTH := ARRAY_LENGTH(TMP_TEXT_ARRAY, 1);
	IF (TMP_FT_LENGTH > 0) THEN
		FOR I IN 1..TMP_FT_LENGTH LOOP
			IF (STRPOS(TMP_SOURCE, TMP_TEXT_ARRAY[I]) > 0) THEN
				OUT_RES := OUT_RES & 1;
			ELSE
				OUT_RES := OUT_RES & 0;
			END IF;
		END LOOP;
	END IF;
	RETURN OUT_RES;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_IS_GRANT
* VERIFICA SI UN USUARIO TIENE PRIVILEGIOS SOBRE UN OBJETO.
* @param IN_OBJECT	NOMBRE DEL OBJETO.
* @param IN_PATH RUTA DONDE SE ENCUENTRA EL OBJETO.
* @param IN_USER NOMBRE DE USUARIO.
* @param IN_SW CUMPLE O NO LAS DOS CONDICIONES.
* return BOOL
*/
CREATE OR REPLACE FUNCTION SII.F_IS_GRANT(
IN IN_OBJECT VARCHAR,
IN IN_PATH VARCHAR,
IN IN_USER VARCHAR,
IN IN_SW INT
)RETURNS BOOL AS
$$
DECLARE
TMP_SW INT;
TMP_CSOBJ_CODIGO VARCHAR;
BEGIN
	--RETURN TRUE;
	SELECT COUNT(U.CUSU_CODIGO) INTO TMP_SW FROM SII.CGG_USUARIO U
	INNER JOIN SII.CGG_SEC_USUARIO_ROL SRL ON SRL.CUSU_CODIGO = U.CUSU_CODIGO AND SRL.CSPER_ESTADO AND SRL.CSROL_CODIGO = '1'
	WHERE U.CUSU_NOMBRE_USUARIO = IN_USER;
	IF (TMP_SW > 0) THEN
		RETURN TRUE;
	END IF;
	
	IF(IN_SW = 0) THEN
		SELECT OBJ.CSOBJ_CODIGO INTO TMP_CSOBJ_CODIGO
		FROM SII.CGG_SEC_OBJETO OBJ
		WHERE OBJ.CSOBJ_NOMBRE = IN_OBJECT;
		IF (TMP_CSOBJ_CODIGO IS NULL) THEN
			RETURN TRUE;
		END IF;
	END IF;
	
	SELECT COUNT(OBJ.CSOBJ_CODIGO) INTO TMP_SW  
	FROM SII.CGG_SEC_OBJETO OBJ
	INNER JOIN SII.CGG_SEC_OBJETO_ROL BJR ON BJR.CSOBJ_CODIGO = OBJ.CSOBJ_CODIGO AND BJR.CSBJR_ESTADO
	INNER JOIN SII.CGG_SEC_USUARIO_ROL SRL ON SRL.CSROL_CODIGO = BJR.CSROL_CODIGO AND SRL.CSPER_ESTADO
	INNER JOIN SII.CGG_USUARIO U ON U.CUSU_CODIGO = SRL.CUSU_CODIGO AND U.CUSU_NOMBRE_USUARIO = IN_USER AND U.CUSU_ESTADO
	WHERE OBJ.CSOBJ_NOMBRE = IN_OBJECT AND 
		CSOBJ_RUTA = IN_PATH AND IN_SW = 1 OR OBJ.CSOBJ_NOMBRE = IN_OBJECT AND IN_SW = 0;

	RETURN (TMP_SW > 0);
END
$$
LANGUAGE 'PLPGSQL' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION sii.F_NUMERO
* FUNCION QUE GENERA CLAVES PARA LAS TABLAS DEL ESQUEMA.
* @param INTABLENAME NOMBRE DE LA TABLA QUE REQUIERE LA CLAVE.
* @param INCOLNAME COLUMNA DE LA TABLA QUE REQUIERE LA CLVAE.
* @param INABR ABREVIATURA DEL NOMBRE DE LA TABLA SOLICITANTE.
* @return NUEVA CLAVE GENERADA.
*/
CREATE OR REPLACE FUNCTION sii.F_NUMERO(
IN INTABLENAME VARCHAR,
IN INCOLNAME VARCHAR,
IN INCOLFECHA VARCHAR
)RETURNS NUMERIC AS
$$
DECLARE
TMP_NUMREGISTROS NUMERIC;
TMP_EXISTS NUMERIC;
OUT_KEY NUMERIC;
BEGIN
	--DESCOMENTAR ESTA LINEA SI SE DESEA RESETEO POR ANIOS.
	--EXECUTE 'SELECT COALESCE(MAX('||INCOLNAME||'),0)+1 FROM sii.'||INTABLENAME ||' WHERE '|| INCOLFECHA||' = EXTRACT( YEAR FROM CURRENT_DATE )' INTO TMP_NUMREGISTROS;
	EXECUTE 'SELECT COALESCE(MAX('||INCOLNAME||'::NUMERIC),0)+1 FROM sii.'||INTABLENAME ||' WHERE LENGTH(TRIM('||INCOLNAME||'::VARCHAR))>0' INTO TMP_NUMREGISTROS;
	
	OUT_KEY := TMP_NUMREGISTROS;
	EXECUTE 'SELECT COUNT('||INCOLNAME||') FROM sii.'||INTABLENAME||' WHERE '||INCOLNAME||' = '||QUOTE_LITERAL(OUT_KEY) INTO TMP_EXISTS;
	IF (TMP_EXISTS > 0) THEN
		FOR I IN 1..TMP_NUMREGISTROS LOOP
			EXECUTE 'SELECT COUNT('||INCOLNAME||') FROM sii.'||INTABLENAME||' WHERE '||INCOLNAME||' = $1' INTO TMP_EXISTS USING I;
			IF (TMP_EXISTS = 0) THEN
				OUT_KEY := I;
				EXIT;
			END IF;
		END LOOP;
	END IF;
	RETURN OUT_KEY;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_TRAMITE_TIPO
* CREA UNA DESCRIPCION SOBRE EL TIPO DE TRAMITE.
* @param IN_CRTST_CODIGO CODIGO DEL TIPO DE SOLICITUD DE TRAMITE
* @return DESCRIPCION
*/
CREATE OR REPLACE FUNCTION SII.F_TRAMITE_TIPO(
IN IN_CRTST_CODIGO VARCHAR
)RETURNS VARCHAR AS
$$
DECLARE
TMP_RECORD RECORD;
TMP_TIPO_TRAMITE VARCHAR;
OUT_TIPO VARCHAR;
BEGIN
	OUT_TIPO := '';
	FOR TMP_RECORD IN (SELECT CRTST_CODIGO, CGG_CRTST_CODIGO, CRTPT_CODIGO, CRTST_DESCRIPCION FROM SII.CGG_RES_TIPO_SOLICITUD_TRAMITE WHERE CRTST_CODIGO = IN_CRTST_CODIGO) LOOP
		IF (TMP_RECORD.CGG_CRTST_CODIGO IS NOT NULL) THEN
			OUT_TIPO := SII.F_TRAMITE_TIPO(TMP_RECORD.CGG_CRTST_CODIGO)||' - '||TMP_RECORD.CRTST_DESCRIPCION;
		ELSE
			SELECT CRTPT_NOMBRE INTO TMP_TIPO_TRAMITE FROM SII.CGG_RES_TIPO_TRAMITE WHERE CRTPT_CODIGO = TMP_RECORD.CRTPT_CODIGO;
			OUT_TIPO := TMP_TIPO_TRAMITE||' - '||TMP_RECORD.CRTST_DESCRIPCION;
		END IF;
	END LOOP;
	RETURN OUT_TIPO;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_PARENT_OF
* VERIFICA LA PERTENENCIA DE UN TIPO DE SOLICITUD.
* @param IN_CRTST_CODIGO CODIGO DEL TIPO DE SOLICITUD DE TRAMITE PADRE
* @param IN_CGG_CRTST_CODIGO CODIGO DEL TIPO DE SOLICITUD DE TRAMITE HIJO
* @return DESCRIPCION
*/
CREATE OR REPLACE FUNCTION SII.F_PARENT_OF(
IN IN_CRTST_CODIGO VARCHAR,
IN IN_CGG_CRTST_CODIGO VARCHAR
)RETURNS BOOLEAN AS
$$
DECLARE
TMP_RECORD RECORD;
OUT_RES BOOLEAN;
BEGIN
	OUT_RES := FALSE;
	FOR TMP_RECORD IN (SELECT CRTST_CODIGO, CGG_CRTST_CODIGO FROM SII.CGG_RES_TIPO_SOLICITUD_TRAMITE WHERE CRTST_CODIGO = IN_CGG_CRTST_CODIGO) LOOP
		IF (TMP_RECORD.CGG_CRTST_CODIGO IS NOT NULL) THEN
			OUT_RES := SII.F_PARENT_OF(IN_CRTST_CODIGO, TMP_RECORD.CGG_CRTST_CODIGO);
		ELSE
			OUT_RES := (TMP_RECORD.CRTST_CODIGO = IN_CRTST_CODIGO);
		END IF;
	END LOOP;
	RETURN OUT_RES;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCION SII.F_ANCESTOR_OF
* OBTIENE LOS CODIGOS DE LOS TIPOS DE SOLICITUD DE LOS QUE HEREDA UN TIPO DE SOLICITUD.
* @param IN_CRTST_CODIGO CODIGO DEL TIPO DE SOLICITUD DE TRAMITE
* @return DESCRIPCION
*/
CREATE OR REPLACE FUNCTION SII.F_ANCESTOR_OF(
IN IN_CRTST_CODIGO VARCHAR
)RETURNS VARCHAR AS
$$
DECLARE
TMP_RECORD RECORD;
TMP_TIPO_TRAMITE VARCHAR;
OUT_TIPOS VARCHAR;
BEGIN
	OUT_TIPOS := '';
	FOR TMP_RECORD IN (SELECT CRTST_CODIGO, CGG_CRTST_CODIGO, CRTPT_CODIGO, CRTST_DESCRIPCION FROM SII.CGG_RES_TIPO_SOLICITUD_TRAMITE WHERE CRTST_CODIGO = IN_CRTST_CODIGO) LOOP
		IF (TMP_RECORD.CGG_CRTST_CODIGO IS NOT NULL) THEN
			OUT_TIPOS := SII.F_ANCESTOR_OF(TMP_RECORD.CGG_CRTST_CODIGO)||' '||TMP_RECORD.CRTST_CODIGO;
		ELSE
			SELECT CRTPT_CODIGO INTO TMP_TIPO_TRAMITE FROM SII.CGG_RES_TIPO_TRAMITE WHERE CRTPT_CODIGO = TMP_RECORD.CRTPT_CODIGO;
			OUT_TIPOS := TMP_TIPO_TRAMITE||' '||TMP_RECORD.CRTST_CODIGO;
		END IF;
	END LOOP;
	IF (LENGTH(OUT_TIPOS) = 0) THEN
		SELECT CRTPT_CODIGO INTO OUT_TIPOS FROM SII.CGG_RES_TIPO_TRAMITE WHERE CRTPT_CODIGO = IN_CRTST_CODIGO;
	END IF;
	RETURN OUT_TIPOS;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

/**
* FUNCTION SII.F_GENERADOR_NUMERACION
* GENERA DINAMICAMENTE LA NUMERACION PARA LOS DOCUMENTOS
* param IN_CGCNF_CODIGO CODIGO DE LA TABLA DE CONFIGURACION CORRESPONDIENTE AL FORMATO DE NUMERACION
* param IN_CAMPO_NUMERACION CAMPO DE LA TABLA QUE CONTIENE LA NUMERACION A GENERAR
* param IN_TABLE IDENTIFICA A LA TABLA.
* @return NUMERACION GENERADA 
*/
CREATE OR REPLACE FUNCTION SII.F_GENERADOR_NUMERACION(
IN IN_TABLE VARCHAR,
IN IN_COLUMN VARCHAR,
IN IN_CGCNF_CODIGO VARCHAR
)RETURNS VARCHAR AS
$$
DECLARE
	TMP_CONFIG VARCHAR;
	TMP_CONFIG_ARRAY VARCHAR[];
	TMP_CONFIG_LEN_ARRAY INTEGER;
	TMP_COUNT INTEGER;
	
	TMP_NUM INTEGER;
	TMP_NUM_COUNT INTEGER;
	TMP_NUM_LEN VARCHAR;
	
	TMP_NUM_COMPLETA VARCHAR;
BEGIN
	TMP_COUNT:=0;
	TMP_NUM_COUNT:=0;
	TMP_NUM_COMPLETA:='';
	SELECT CGCNF_VALOR_CADENA INTO TMP_CONFIG	FROM SII.CGG_CONFIGURACION	WHERE CGCNF_CODIGO = IN_CGCNF_CODIGO;
	TMP_CONFIG_ARRAY := STRING_TO_ARRAY(UPPER(TMP_CONFIG), '-');	
	TMP_CONFIG_LEN_ARRAY:=ARRAY_LENGTH(TMP_CONFIG_ARRAY,1);
	
	IF TMP_CONFIG_LEN_ARRAY > 0 THEN
		FOR I IN 1..TMP_CONFIG_LEN_ARRAY LOOP
			TMP_NUM:=0;
			IF TMP_CONFIG_ARRAY[I] ='#' THEN
				TMP_NUM_COUNT:=TMP_NUM_COUNT+1;
				EXECUTE 'SELECT MAX ( ((STRING_TO_ARRAY('||  IN_COLUMN  ||' ,''-''))[$1])::NUMERIC  ) +1 FROM SII.'||IN_TABLE||';' INTO TMP_NUM USING I;
				IF TMP_NUM IS NULL THEN
					TMP_NUM :=1;
				END IF;
			END IF;
			IF TMP_NUM=0 THEN
				IF LENGTH(TMP_NUM_COMPLETA)=0 THEN
					TMP_NUM_COMPLETA:=TMP_CONFIG_ARRAY[I];
				ELSE
					TMP_NUM_COMPLETA:=TMP_NUM_COMPLETA||'-'||TMP_CONFIG_ARRAY[I];
				END IF;
			ELSE
				TMP_NUM_COMPLETA:=TMP_NUM_COMPLETA||'-'||(TMP_NUM::VARCHAR);
			END IF;
		END LOOP;		
	END IF;
	RETURN TMP_NUM_COMPLETA;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;

CREATE OR REPLACE FUNCTION ISNUMERIC(TEXT) RETURNS BOOLEAN AS 
'SELECT $1 ~ ''^[0-9]+$''' 
LANGUAGE 'SQL';

/**
* FUNCION SII.F_CGG_RES_PERSONA_INDEXADO
* CREA UN INDICE CON LA INFORMACION MAS RELEVANTE DE PERSONA PARA HACER LAS BUSQUEDAS
* @return VOID
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_RES_PERSONA_INDEXADO(
)RETURNS VOID AS
$BODY$
DECLARE
TMP_RECORD RECORD;
BEGIN
	FOR TMP_RECORD IN (SELECT 
		crper_codigo,
		crper_nombres,
		crper_apellido_paterno,
		crper_apellido_materno,
		crper_num_doc_identific,
		crper_fecha_nacimiento,
		crper_lugar_nacimiento,
		crper_observaciones,
		crper_numero_residencia,
		crper_numero_expediente,
		crper_fecha_archivo,
		crper_fecha_ultimo_empleo,
		crper_aspiracion_salarial,
		crper_fecha_defuncion,
		crper_numero_acta
		FROM SII.cgg_res_persona) LOOP
		UPDATE SII.cgg_res_persona SET crper_index = to_tsvector(TMP_RECORD::VARCHAR)
			WHERE crper_codigo = TMP_RECORD.crper_codigo;
	END LOOP;
END
$BODY$
LANGUAGE plpgsql VOLATILE COST 100;

CREATE OR REPLACE FUNCTION num_days(int, int) RETURNS float8 AS -- years, months
	'SELECT date_part(''day'',
		(($1::text || ''-'' || $2::text || ''-01'')::date
			+ ''1 month''::interval
			- ''1 day''::interval)) AS days'
LANGUAGE 'sql';

CREATE OR REPLACE FUNCTION SII.F_ULTIMO_AEROPUERTO_ENTRADA(INCRPER_CODIGO VARCHAR
)RETURNS VARCHAR AS
$BODY$
DECLARE
	CODIGO_AEROPUERTO VARCHAR(20);	
BEGIN
	
	CODIGO_AEROPUERTO := '';
	
	SELECT COALESCE((SELECT CCTN_CODIGO FROM CGG_RES_AEROPUERTO WHERE CARPT_CODIGO = CGG_CARPT_CODIGO),'74') CCTN_CODIGO INTO CODIGO_AEROPUERTO
	FROM CGG_RES_MOVILIDAD M
	INNER JOIN CGG_RES_PERSONA P
	ON P.CRPER_CODIGO = M.CRPER_CODIGO
	WHERE P.CRPER_CODIGO = INCRPER_CODIGO
	AND M.CRMOV_TIPO_OPERACION = 0
	ORDER BY CRMOV_FECHA_VIAJE DESC LIMIT 1;	
	RETURN CODIGO_AEROPUERTO;
END
$BODY$
LANGUAGE plpgsql VOLATILE COST 100;