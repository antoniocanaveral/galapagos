/**
* FUNCION SII.F_CGG_REGLA_VALIDACION_SELECT_TIPO_SOLICITUD
* SELECCIONA LAS REGLAS DE VALIDACION EN LA TABLA SII.CGG_REGLA_VALIDACION RELACIONADA CON SII.CGG_RES_TIPO_SOLICITUD_REGLA.
* @param IN_CRTST_CODIGO IDENTIFICATIVO UNICO DE REGISTRO DE TIPO DE SOLICITUD
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION_SELECT_TIPO_SOLICITUD(
IN IN_CRTST_CODIGO SII.CGG_RES_TIPO_SOLICITUD_REGLA.CRTST_CODIGO%TYPE
)RETURNS SETOF REFCURSOR AS
$$
DECLARE
	TMP_REF REFCURSOR;
BEGIN
	OPEN TMP_REF FOR
	SELECT
		CRVAL.CRVAL_CODIGO, 
		CRVAL.CGCNF_CODIGO, 
		CRVAL.CRVAL_NOMBRE, 
		CRVAL.CRVAL_DESCRIPCION, 
		CRVAL.CRVAL_FUNCION_VALIDACION, 
		CRVAL.CRVAL_OPERADOR_COMPARADOR, 
		CRVAL.CRVAL_VALOR_LIBRE, 
		CRVAL.CRVAL_RESULTADO_ACEPTACION, 
		CRVAL.CRVAL_SUGERENCIA, 
		CRVAL.CRVAL_TIPO, 
		CRVAL.CRVAR_FECHA_INICIO, 
		CRVAL.CRVAR_FECHA_FIN, 
		CRVAL.CRVAL_VALOR_1, 
		CRVAL.CRVAL_VALOR_2, 
		CRVAL.CRVAL_ESTADO, 
		CRVAL.CRVAL_FECHA_INSERT, 
		CRVAL.CRVAL_USUARIO_INSERT, 
		CRVAL.CRVAL_FECHA_UPDATE, 
		CRVAL.CRVAL_USUARIO_UPDATE,
		CRTSE.CRTSE_CAMPO_EVALUACION
	 FROM CGG_REGLA_VALIDACION CRVAL 
	 LEFT JOIN CGG_RES_TIPO_SOLICITUD_REGLA CRTSE ON CRVAL.CRVAL_CODIGO = CRTSE.CRVAL_CODIGO AND CRTSE.CRTSE_ESTADO
	WHERE CRVAL_ESTADO AND 
		CRTSE.CRTST_CODIGO = IN_CRTST_CODIGO;
	RETURN NEXT TMP_REF;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;


/**
* FUNCION SII.F_CGG_REGLA_VALIDACION_SELECT_OPERACION_VALIDACION_BY_FORM
* SELECCIONA LAS REGLAS DE VALIDACION EN LA TABLA SII.CGG_REGLA_VALIDACION RELACIONADA CON SII.CGG_OPERACION_VALIDACION.
* @param IN_COPVL_FORMULARIO DESCRIPCION DEL FORMULARIO SOBRE EL QUE SE APLICARA LA VALIDACION
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION_SELECT_OPERACION_VALIDACION_BY_FORM(
IN IN_COPVL_FORMULARIO SII.CGG_OPERACION_VALIDACION.COPVL_FORMULARIO%TYPE
)RETURNS SETOF REFCURSOR AS
$$
DECLARE
	TMP_REF REFCURSOR;
BEGIN
	OPEN TMP_REF FOR
	SELECT
		CRVAL.CRVAL_CODIGO, 
		CRVAL.CGCNF_CODIGO, 
		CRVAL.CRVAL_NOMBRE, 
		CRVAL.CRVAL_DESCRIPCION, 
		CRVAL.CRVAL_FUNCION_VALIDACION, 
		CRVAL.CRVAL_OPERADOR_COMPARADOR, 
		CRVAL.CRVAL_VALOR_LIBRE, 
		CRVAL.CRVAL_RESULTADO_ACEPTACION, 
		CRVAL.CRVAL_SUGERENCIA, 
		CRVAL.CRVAL_TIPO, 
		CRVAL.CRVAR_FECHA_INICIO, 
		CRVAL.CRVAR_FECHA_FIN, 
		CRVAL.CRVAL_VALOR_1, 
		CRVAL.CRVAL_VALOR_2,
		CORV.CORV_CAMPO_EVALUACION CRTSE_CAMPO_EVALUACION
	 FROM CGG_REGLA_VALIDACION CRVAL INNER JOIN CGG_OPERACION_REGLA_VALIDACION CORV
	ON (CRVAL.CRVAL_CODIGO = CORV.CRVAL_CODIGO)
	 INNER JOIN CGG_OPERACION_VALIDACION COPVL
	ON (COPVL.COPVL_CODIGO = CORV.COPVL_CODIGO)
	WHERE CRVAL_ESTADO = TRUE
	AND CORV.CORV_ESTADO = TRUE
	AND UPPER(COPVL.COPVL_FORMULARIO) = UPPER(IN_COPVL_FORMULARIO);
	RETURN NEXT TMP_REF;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;



/**
* FUNCION SII.F_CGG_REGLA_VALIDACION_SELECT_OPERACION_VALIDACION
* SELECCIONA LAS REGLAS DE VALIDACION EN LA TABLA SII.CGG_REGLA_VALIDACION RELACIONADA CON SII.CGG_OPERACION_VALIDACION.
* @param IN_COPVL_CODIGO CODIGO UNICO DE IDENTIFICACION DEL LA OPERACION DE VALIDACION
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION_SELECT_OPERACION_VALIDACION(
IN IN_COPVL_CODIGO SII.CGG_OPERACION_REGLA_VALIDACION.COPVL_CODIGO%TYPE
)RETURNS SETOF REFCURSOR AS
$$
DECLARE
	TMP_REF REFCURSOR;
BEGIN
	OPEN TMP_REF FOR
	SELECT
		CRVAL.CRVAL_CODIGO, 
		CRVAL.CGCNF_CODIGO, 
		CRVAL.CRVAL_NOMBRE, 
		CRVAL.CRVAL_DESCRIPCION, 
		CRVAL.CRVAL_FUNCION_VALIDACION, 
		CRVAL.CRVAL_OPERADOR_COMPARADOR, 
		CRVAL.CRVAL_VALOR_LIBRE, 
		CRVAL.CRVAL_RESULTADO_ACEPTACION, 
		CRVAL.CRVAL_SUGERENCIA, 
		CRVAL.CRVAL_TIPO, 
		CRVAL.CRVAR_FECHA_INICIO, 
		CRVAL.CRVAR_FECHA_FIN, 
		CRVAL.CRVAL_VALOR_1, 
		CRVAL.CRVAL_VALOR_2,
		CORV.CORV_CAMPO_EVALUACION CRTSE_CAMPO_EVALUACION
	 FROM CGG_REGLA_VALIDACION CRVAL INNER JOIN CGG_OPERACION_REGLA_VALIDACION CORV
	ON (CRVAL.CRVAL_CODIGO = CORV.CRVAL_CODIGO)
	WHERE CRVAL_ESTADO = TRUE
	AND UPPER(CORV.COPVL_CODIGO) = UPPER(IN_COPVL_CODIGO);
	RETURN NEXT TMP_REF;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;



/**
* FUNCION SII.F_CGG_REGLA_VALIDACION_SELECT_LITE_PARAMS
* SELECCIONA LAS REGLAS DE VALIDACION EN LA TABLA SII.CGG_REGLA_VALIDACION RELACIONADA CON PG_PROC.
* @param IN_USER_NAME NOMBRE DE USUARIO DEL SERVIDOR DE APP. O DE LA BASE DE DATOS
* @return REFCURSOR
*/
CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION_SELECT_LITE_PARAMS(
IN IN_USER_NAME VARCHAR
)RETURNS SETOF REFCURSOR AS
$$
DECLARE
	TMP_REF REFCURSOR;
BEGIN
	OPEN TMP_REF FOR
	SELECT
		CRVAL_CODIGO, 
		CRVAL_NOMBRE, 
		CRVAL_DESCRIPCION, 
		CRVAL_FUNCION_VALIDACION,
		TRIM(PROARGNAMES::TEXT,'{}')  AS CRVAL_FUNCION_PLSQL_PARAMETROS
	FROM SII.CGG_REGLA_VALIDACION
	INNER JOIN PG_PROC ON (UPPER(PRONAME) = UPPER(CRVAL_FUNCION_VALIDACION))
	WHERE CRVAL_ESTADO = TRUE;
	RETURN NEXT TMP_REF;
END
$$
LANGUAGE 'plpgsql' VOLATILE CALLED ON NULL INPUT;


/**
*FUNCION F_CGG_REGLA_VALIDACION
*VALIDA LA INFORMACION INGRESADA.
* @param INPARAMETRO IDENTIFICATIVO DE PARAMETRO
* @param INOPERADOR IDENTIFICATIVO DE OPERADOR
* @param INVALORCOMPARACION VALOR DE COMPARACION
* @return CHARACTER VARYING
*/

CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION(INPARAMETRO CHARACTER VARYING,INOPERADOR CHARACTER VARYING,INVALORCOMPARACION CHARACTER VARYING)
  RETURNS CHARACTER VARYING AS
$BODY$
DECLARE
	TMP_RESULTADO BOOLEAN;
	TMP_VALOR_COMPARACION CHARACTER VARYING;
	TMP_CADENA CHARACTER VARYING;
BEGIN
	TMP_VALOR_COMPARACION := INVALORCOMPARACION; 
	IF(SUBSTRING(INVALORCOMPARACION,0,6) ='CGCNF' OR SUBSTRING(INVALORCOMPARACION,0,5) ='CONF') THEN
		SELECT CGCNF_VALOR_NUMERICO INTO TMP_VALOR_COMPARACION
		FROM SII.CGG_CONFIGURACION WHERE CGCNF_CODIGO = INVALORCOMPARACION;
		TMP_CADENA := INPARAMETRO|| INOPERADOR|| TMP_VALOR_COMPARACION;
	ELSE
		IF( ISNUMERIC(INPARAMETRO) AND ISNUMERIC(TMP_VALOR_COMPARACION)) THEN
			TMP_CADENA := INPARAMETRO || INOPERADOR || TMP_VALOR_COMPARACION;
		ELSE
			TMP_CADENA := quote_literal(INPARAMETRO)|| INOPERADOR|| quote_literal(TMP_VALOR_COMPARACION);	
		END IF;		
	END IF;
	EXECUTE 'SELECT '|| TMP_CADENA INTO TMP_RESULTADO;
	RETURN  TMP_RESULTADO::VARCHAR;
END
$BODY$
  LANGUAGE 'PLPGSQL' VOLATILE
  COST 100;


/**
*FUNCION F_CGG_REGLA_VALIDACION
*VALIDA LA INFORMACION INGRESADA.
* @param INPARAMETRO IDENTIFICATIVO DE PARAMETRO
* @param INOPERADOR IDENTIFICATIVO DE OPERADOR
* @param INVALORCOMPARACION VALOR DE COMPARACION
* @return CHARACTER VARYING
*/

CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_VALIDACION(INPARAMETRO INTEGER,INOPERADOR CHARACTER VARYING,INVALORCOMPARACION INTEGER)
  RETURNS CHARACTER VARYING AS
$BODY$
DECLARE
	TMP_RESULTADO BOOLEAN;
	TMP_VALOR_COMPARACION CHARACTER VARYING;
	TMP_CADENA CHARACTER VARYING;
BEGIN
	TMP_VALOR_COMPARACION := INVALORCOMPARACION; 
	IF(SUBSTRING(INVALORCOMPARACION,0,6) ='CGCNF') THEN
		SELECT CGCNF_VALOR_NUMERICO INTO TMP_VALOR_COMPARACION
		FROM SII.CGG_CONFIGURACION WHERE CGCNF_CODIGO = INVALORCOMPARACION;
	END IF;
	TMP_CADENA := INPARAMETRO|| INOPERADOR|| TMP_VALOR_COMPARACION;
	EXECUTE 'SELECT'|| TMP_CADENA INTO TMP_RESULTADO;
	RETURN  TMP_RESULTADO::VARCHAR;
END
$BODY$
  LANGUAGE 'PLPGSQL' VOLATILE
  COST 100;  
  
  
/**
* FUNCION DE PRUEBA
*FUNCION F_CGG_REGLA_VALIDACION
*VALIDA LA INFORMACION INGRESADA.
* @param INPARAMETRO1  PRIMER PARAMETRO
* @param INPARAMETRO2 SEGUNDO PARAMETRO
* @param INOPERADOR IDENTIFICATIVO DE OPERADOR
* @param INVALORCOMPARACION VALOR DE COMPARACION
* @return CHARACTER VARYING
*/

CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_SUMA(
INPARAMETRO1 NUMERIC,
INPARAMETRO2 NUMERIC,
INOPERADOR CHARACTER VARYING,
INVALORCOMPARACION CHARACTER VARYING
)RETURNS CHARACTER VARYING AS
$BODY$
DECLARE
	TMP_RESULTADO CHARACTER VARYING;
	TMP_OPERACION CHARACTER VARYING;
BEGIN
	TMP_OPERACION := INPARAMETRO1+INPARAMETRO2; 
	SELECT SII.F_CGG_REGLA_VALIDACION(TMP_OPERACION,INOPERADOR,INVALORCOMPARACION) INTO TMP_RESULTADO;
	RETURN  TMP_RESULTADO;
END
$BODY$
  LANGUAGE 'PLPGSQL' VOLATILE
  COST 100;

/**
* FUNCION DE PRUEBA
*FUNCION F_CGG_REGLA_VALIDACION
*VALIDA LA INFORMACION INGRESADA.
* @param INPARAMETRO1  PRIMER PARAMETRO
* @param INPARAMETRO2 SEGUNDO PARAMETRO
* @param INOPERADOR IDENTIFICATIVO DE OPERADOR
* @param INVALORCOMPARACION VALOR DE COMPARACION
* @return CHARACTER VARYING
*/

CREATE OR REPLACE FUNCTION SII.F_CGG_REGLA_RESTA(INPARAMETRO1 NUMERIC,INPARAMETRO2 NUMERIC,INOPERADOR CHARACTER VARYING,INVALORCOMPARACION CHARACTER VARYING)
  RETURNS CHARACTER VARYING AS
$BODY$
DECLARE
	TMP_RESULTADO CHARACTER VARYING;
	TMP_OPERACION CHARACTER VARYING;
BEGIN
	TMP_OPERACION := INPARAMETRO1-INPARAMETRO2; 
	SELECT SII.F_CGG_REGLA_VALIDACION(TMP_OPERACION,INOPERADOR,INVALORCOMPARACION) INTO TMP_RESULTADO;
	RETURN  TMP_RESULTADO;
END
$BODY$
  LANGUAGE 'PLPGSQL' VOLATILE
  COST 100;

/**
*FUNCION sii.function_args.
*SELECCIONA INFORMACION.
*@param IN funcname NOMBRE DE LA FUNCION
*@param IN schema IDENTIFICATIVO DEL ESQUEMA
*@param pos POSICION DEL ARGUMENTO
*@param direction DIRECCION DEL ARGUMENTO
*@param argname NOMBRE DEL ARGUMENTO
*@param datatype TIPO DE DATO
*@return SETOF RECORD AS $$DECLARE
*/

CREATE OR REPLACE FUNCTION sii.function_args(
  IN funcname character varying,
  IN schema character varying,
  OUT pos integer,
  OUT direction character,
  OUT argname character varying,
  OUT datatype character varying)
RETURNS SETOF RECORD AS $$DECLARE
  rettype character varying;
  argtypes oidvector;
  allargtypes oid[];
  argmodes "char"[];
  argnames text[];
  mini integer;
  maxi integer;
BEGIN
  /* get object ID of function */
  SELECT INTO rettype, argtypes, allargtypes, argmodes, argnames
         CASE
         WHEN pg_proc.proretset
         THEN 'setof ' || pg_catalog.format_type(pg_proc.prorettype, NULL)
         ELSE pg_catalog.format_type(pg_proc.prorettype, NULL) END,
         pg_proc.proargtypes,
         pg_proc.proallargtypes,
         pg_proc.proargmodes,
         pg_proc.proargnames
    FROM pg_catalog.pg_proc
         JOIN pg_catalog.pg_namespace
         ON (pg_proc.pronamespace = pg_namespace.oid)
   WHERE pg_proc.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
     AND (pg_proc.proargtypes[0] IS NULL
      OR pg_proc.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
     AND NOT pg_proc.proisagg
     AND pg_proc.proname = funcname
     AND pg_namespace.nspname != 'information_schema'
     AND pg_catalog.pg_function_is_visible(pg_proc.oid);
 
  /* bail out if not found */
  IF NOT FOUND THEN
    RETURN;
  END IF;
 
  /* return a row for the return value */
  pos = 0;
  direction = 'o'::char;
  argname = 'RETURN VALUE';
  datatype = rettype;
  RETURN NEXT;
 
  /* unfortunately allargtypes is NULL if there are no OUT parameters */
  IF allargtypes IS NULL THEN
    mini = array_lower(argtypes, 1); maxi = array_upper(argtypes, 1);
  ELSE
    mini = array_lower(allargtypes, 1); maxi = array_upper(allargtypes, 1);
  END IF;
  IF maxi < mini THEN RETURN; END IF;
 
  /* loop all the arguments */
  FOR i IN mini .. maxi LOOP
    pos = i - mini + 1;
    IF argnames IS NULL THEN
      argname = NULL;
    ELSE
      argname = argnames[pos];
    END IF;
    IF allargtypes IS NULL THEN
      direction = 'i'::char;
      datatype = pg_catalog.format_type(argtypes[i], NULL);
    ELSE
      direction = argmodes[i];
      datatype = pg_catalog.format_type(allargtypes[i], NULL);
    END IF;
    RETURN NEXT;
  END LOOP;
 
  RETURN;
END;$$ LANGUAGE plpgsql STABLE STRICT SECURITY INVOKER;

COMMENT ON FUNCTION public.function_args(character varying, character
varying)
IS $$For a function name and schema, this procedure selects for each
argument the following data:
- position in the argument list (0 for the return value)
- direction 'i', 'o', or 'b'
- name (NULL if not defined)
- data type$$;







