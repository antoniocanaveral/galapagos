ALTER TABLE SII.CGG_SECUENCIA ADD COLUMN CRRSD_MODALIDAD NUMERIC;
ALTER TABLE SII.CGG_SECUENCIA ADD COLUMN CISLA_CODIGO VARCHAR(20);

INSERT INTO SII.CGG_SECUENCIA VALUES ('RESPER1',0,2016,0,'CISLA1');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESPER2',0,2016,0,'CISLA2');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESPER3',0,2016,0,'CISLA3');

INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTMP1',0,2016,1,'CISLA1');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTMP2',0,2016,1,'CISLA2');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTMP3',0,2016,1,'CISLA3');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTMP4',0,2016,1,NULL);

INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTRA1',0,2016,2,'CISLA1');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTRA2',0,2016,2,'CISLA2');
INSERT INTO SII.CGG_SECUENCIA VALUES ('RESTRA3',0,2016,2,'CISLA3');


CREATE OR REPLACE FUNCTION SII.CGG_NEXT_VAL(v_modalidad numeric, v_cisla_codigo character varying)
  RETURNS NUMERIC AS
$BODY$
DECLARE x NUMERIC;
BEGIN
    SELECT cgscn_secuencia INTO x FROM SII.CGG_SECUENCIA WHERE CRRSD_MODALIDAD = v_modalidad AND CISLA_CODIGO = v_cisla_codigo;
    UPDATE SII.CGG_SECUENCIA SET cgscn_secuencia = x +1 WHERE CRRSD_MODALIDAD = v_modalidad AND CISLA_CODIGO = v_cisla_codigo;
    RETURN x;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;


CREATE OR REPLACE FUNCTION f_cgg_res_residencia_generar(
    in_user_name character varying,
    in_crtra_codigo character varying,
    in_crseg_codigo character varying)
  RETURNS character varying AS
$BODY$
DECLARE
TMP_CRTST_CODIGO VARCHAR;
TMP_PERMANENTE VARCHAR;
TMP_TEMPORAL VARCHAR;
TMP_TRANSEUNTE VARCHAR;
TMP_IS_PERMANENTE BOOLEAN;
TMP_IS_TEMPORAL BOOLEAN;
TMP_IS_TRANSEUNTE BOOLEAN;
--FECHA DE INGRESO
TMP_CRTRA_FECHA_INGRESO TIMESTAMP WITH TIME ZONE;
--CODIGO DE RESIDENCIA
TMP_CRRSD_CODIGO VARCHAR;
--CODIGO DE LA NUEVA RESIDENCIA
TMP_NEW_CRRSD_CODIGO VARCHAR;
--FECHA DE CADUCIDAD DE LA RESIDENCIA
TMP_CRRSD_FECHA_CADUCIDAD TIMESTAMP WITH TIME ZONE;
--CODIGO DEL AUSPICIANTE DEL TRAMITE
TMP_CRPER_CODIGO VARCHAR;
--MODALIDAD DE LA RESIDENCIA ACTUAL
TMP_CRRSD_MODALIDAD INT;
--NUMERO DE RESIDENCIA ACTUAL
TMP_CRRSD_NUMERO INT;
--CODIGO DEL BENEFICIARIO DEL TRAMITE
TMP_CGG_CRPER_CODIGO VARCHAR;
--DIAS DE AUTORIZACION DE PERMANENCIA DENTRO DE LA PROVINCIA
TMP_DIAS_AUTORIZADOS INT;
--FECHA DE CADUCIDAD DE LA AUTORIZACION DE PERMANENCIA DENTRO DE LA PROVINCIA
TMP_FECHA_CADUCIDAD TIMESTAMP WITH TIME ZONE;
--CODIGO DE LA RESOLUCION ASOCIADA AL TRAMITE
TMP_CRRES_CODIGO VARCHAR;
--ESTADO DE LA RESOLUCION ASOCIADA AL TRAMITE
TMP_CRRES_ESTADO_RESOLUCION INT;
--BUFFER PARA ALMANCENAR EL CODIGO ASIGNADO EN LA INSERCION DE UN NUEVO REGISTRO.
TMP_CODIGO VARCHAR;
--FECHA DE APROBACION DE LA RESOLUCION
TMP_CRRES_FECHA_EMISION TIMESTAMP WITH TIME ZONE;
--NUMERO DE RESIDENCIA MAXIMO
TMP_MAX_RESIDENCIA INT;
--INDICE DE LA ISLA DONDE SE PRESENTO EL TRAMITE
TMP_CISLA_INDICE INT;
--INDICE PARA TIPO DE SOLICITUD PERMANENTE
TMP_INDICE_PERM INT;
--INDICE DEL TIPO DE RESIDENCIA
TMP_INDICE INT;
--INDICE PARA TIPO DE SOLICITUD TEMPORAL
TMP_INDICE_TEMP INT;
--MODALIDAD DE LA RESIDENCIA PERMANENTE O TEMPORAL
TMP_MODALIDAD INT;
--REGISTRO DE TABLA DE SEGUIMIENTO
TMP_RSGM RECORD;
--ESTADO DEL TRAMITE
TMP_CRETT_CODIGO VARCHAR;
--SI EL TIPO DE SOLICITUD DEBE GENERAR TRANSEUNTE TEMPORAL
TMP_APLICA_OTRO BOOLEAN;
--OBTIENE EL ESTADO DE TRAMITE PARA CUANDO ESTA LISTO PARA TRATARSE EN COMITE
TMP_ESTADO_COMITE VARCHAR;
--SI LA RESIDENCIA TIENE UN TRAMITE PENDIENTE
TMP_CRRSD_TRAMITE_PENDIENTE BOOLEAN;
--REGISTRO DE FASE QUE ESTA CUMPLIENDO EL SEGUIMIENTO
TMP_RFS RECORD;
--ISLA DE PRESENTACION
TMP_CISLA_CODIGO VARCHAR;
--ISLA DE LA OBTENCION DE LA RESIDENCIA
TMP_RSD_ISLA VARCHAR;
--CODIGO DE LA TABLA RESOL_TRAMITE
TMP_CRRST_CODIGO VARCHAR;
BEGIN
TMP_CRRSD_TRAMITE_PENDIENTE := FALSE;

--OBTIENE EL REGISTRO DEL TABLA SEGUIMIENTO
SELECT * INTO TMP_RSGM
FROM SII.CGG_RES_SEGUIMIENTO
WHERE CRSEG_CODIGO = IN_CRSEG_CODIGO AND
CRTRA_CODIGO = IN_CRTRA_CODIGO;

--OBTIENE LA FASE QUE ESTA CUMPLIENDO EL SEGUIMIENTO
SELECT * INTO TMP_RFS
FROM SII.CGG_RES_FASE
WHERE CRFAS_CODIGO = TMP_RSGM.CRFAS_CODIGO;

--OBTIENE EL TIPO DE SOLICITUD DEL TRAMITE
SELECT TST.CRRES_CODIGO,
TST.CRTST_CODIGO,
TRM.CRPER_CODIGO,
TRM.CGG_CRPER_CODIGO,
TRM.CRTRA_DIAS_PERMANENCIA,
TRM.CRTRA_FECHA_INGRESO,
TRM.CRTRA_FECHA_SALIDA,
SL.CISLA_INDICE,
TRM.CRETT_CODIGO,
TST.CRTST_APLICA_OTRO,
TRM.CISLA_CODIGO
INTO TMP_CRRES_CODIGO,
TMP_CRTST_CODIGO,
TMP_CRPER_CODIGO,
TMP_CGG_CRPER_CODIGO,
TMP_DIAS_AUTORIZADOS,
TMP_CRTRA_FECHA_INGRESO,
TMP_FECHA_CADUCIDAD,
TMP_CISLA_INDICE,
TMP_CRETT_CODIGO,
TMP_APLICA_OTRO,
TMP_CISLA_CODIGO
FROM SII.CGG_RES_TRAMITE TRM
INNER JOIN SII.CGG_ISLA SL ON SL.CISLA_CODIGO = TRM.CISLA_CODIGO AND SL.CISLA_ESTADO
INNER JOIN SII.CGG_RES_TIPO_SOLICITUD_TRAMITE TST ON TST.CRTST_CODIGO = case when TRM.CHANGE_CRTST_CODIGO is null then TRM.CRTST_CODIGO else TRM.CHANGE_CRTST_CODIGO end AND TST.CRTST_ESTADO
WHERE TRM.CRTRA_CODIGO = IN_CRTRA_CODIGO;

SELECT CRRST_CODIGO INTO TMP_CRRST_CODIGO
FROM SII.CGG_RES_RESOL_TRAMITE
WHERE CRTRA_CODIGO = IN_CRTRA_CODIGO AND
CRRST_ESTADO;

IF (TMP_CRRES_CODIGO IS NOT NULL AND TMP_CRRST_CODIGO IS NULL) THEN
SELECT SII.F_CGG_RES_RESOL_TRAMITE_INSERT(
'KEYGEN'::VARCHAR,
TMP_CRRES_CODIGO,
IN_CRTRA_CODIGO,
TRUE,
IN_USER_NAME
) INTO TMP_CODIGO;
END IF;

--OBTIENE INFORMACION DE LA RESOLUCION ASOCIADA AL TRAMITE
SELECT RSL.CRRES_CODIGO,
RSL.CRRES_ESTADO_RESOLUCION,
RSL.CRRES_FECHA_EMISION
INTO TMP_CRRES_CODIGO,
TMP_CRRES_ESTADO_RESOLUCION,
TMP_CRRES_FECHA_EMISION
FROM SII.CGG_RES_RESOL_TRAMITE RST
INNER JOIN SII.CGG_RES_RESOLUCION RSL ON RSL.CRRES_CODIGO = RST.CRRES_CODIGO AND RSL.CRRES_ESTADO
WHERE RST.CRTRA_CODIGO = IN_CRTRA_CODIGO AND
RST.CRRST_ESTADO;

--SI LA RESIDENCIA SE APRUEBA CON RESOLUCION ANTERIOR, SE ESCOGE LA FECHA DE APROBACION DEL SEGUIMIENTO
IF (TMP_CODIGO IS NOT NULL OR TMP_CRRES_CODIGO IS NULL) THEN
SELECT CRSEG_FECHA_DESPACHO INTO TMP_CRRES_FECHA_EMISION
FROM SII.CGG_RES_SEGUIMIENTO SGM
WHERE SGM.CRTRA_CODIGO = IN_CRTRA_CODIGO AND
SGM.CRSEG_ESTADO
ORDER BY CRSEG_FECHA_DESPACHO DESC
LIMIT 1;
END IF;

--OBTIENE EL TIPO DE SOLICITUD PADRE PARA RESIDENCIA PERMANENTE
SELECT CGCNF_VALOR_CADENA INTO TMP_PERMANENTE
FROM SII.CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '03';
--OBTIENE EL INDICE DEL TIPO DE SOLICITUD DE TRAMITE PARA PERMANENTES
SELECT CRTST_INDICE INTO TMP_INDICE_PERM
FROM SII.CGG_RES_TIPO_SOLICITUD_TRAMITE
WHERE CRTST_CODIGO = TMP_PERMANENTE;

--OBTIENE EL TIPO DE SOLICITUD PADRE PARA RESIDENCIA TEMPORAL
SELECT CGCNF_VALOR_CADENA INTO TMP_TEMPORAL
FROM SII.CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '04';
--OBTIENE EL INDICE DEL TIPO DE SOLICITUD DE TRAMITE PARA TEMPORALES
SELECT CRTST_INDICE INTO TMP_INDICE_TEMP
FROM SII.CGG_RES_TIPO_SOLICITUD_TRAMITE
WHERE CRTST_CODIGO = TMP_TEMPORAL;

--OBTIENE EL TIPO DE SOLICITUD PADRE PARA TRANSEUNTES
SELECT CGCNF_VALOR_CADENA INTO TMP_TRANSEUNTE
FROM SII.CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '05';

--VERIFICA SI EL TIPO DE SOLICITUD DEL TRAMITE ES PARA RESIDENCIA PERMANENTE O TEMPORAL
TMP_IS_PERMANENTE := SII.F_PARENT_OF(TMP_PERMANENTE, TMP_CRTST_CODIGO);
TMP_IS_TEMPORAL := SII.F_PARENT_OF(TMP_TEMPORAL, TMP_CRTST_CODIGO);
TMP_IS_TRANSEUNTE := SII.F_PARENT_OF(TMP_TRANSEUNTE, TMP_CRTST_CODIGO);

--OBTIENE EL ESTADO DE TRAMITE QUE INDICA QUE EL TRAMITE ESTA LISTO PARA TRATARSE EN COMITE
SELECT CGCNF_VALOR_CADENA INTO TMP_ESTADO_COMITE
FROM SII.CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '01';

IF (TMP_IS_TEMPORAL AND TMP_APLICA_OTRO AND (TMP_RFS.CRETT_CODIGO = TMP_ESTADO_COMITE OR TMP_RFS.CGG_CRETT_CODIGO = TMP_ESTADO_COMITE)) THEN
TMP_IS_TEMPORAL = FALSE;
TMP_IS_TRANSEUNTE = TRUE;
TMP_CRTST_CODIGO := TMP_TRANSEUNTE;
TMP_CRRSD_TRAMITE_PENDIENTE := TRUE;
END IF;

IF(NOT TMP_IS_PERMANENTE AND NOT TMP_IS_TEMPORAL AND NOT TMP_IS_TRANSEUNTE) THEN
RETURN 'El tramite indicado no genera residencia para el beneficiario.';
END IF;

IF(TMP_IS_PERMANENTE)THEN
TMP_MODALIDAD := 0;
TMP_CRRSD_FECHA_CADUCIDAD := NULL;
TMP_INDICE := TMP_INDICE_PERM;
ELSIF(TMP_IS_TEMPORAL OR TMP_IS_TRANSEUNTE)THEN
TMP_MODALIDAD := 1;
TMP_INDICE := TMP_INDICE_TEMP;
IF(TMP_DIAS_AUTORIZADOS <= 0 )THEN
TMP_CRRSD_FECHA_CADUCIDAD := TMP_FECHA_CADUCIDAD::DATE;
ELSE
TMP_CRRSD_FECHA_CADUCIDAD := TMP_CRRES_FECHA_EMISION::DATE + TMP_DIAS_AUTORIZADOS;
END IF;
TMP_CRRSD_FECHA_CADUCIDAD := TMP_CRRSD_FECHA_CADUCIDAD + interval '23:59:00';
END IF;

IF(TMP_IS_TRANSEUNTE)THEN
TMP_MODALIDAD := 2;
END IF;
--OBTIENE EL NUMERO DE RESIDENCIA MAXIMO DE ENTRE TODAS LAS RESIDENCIAS DE ACUERDO A LA MODALIDAD

SELECT CGG_NEXT_VAL(TMP_MODALIDAD, TMP_CISLA_CODIGO) INTO TMP_MAX_RESIDENCIA;
--SELECT MAX(CRRSD_NUMERO) INTO TMP_MAX_RESIDENCIA
--FROM SII.CGG_RES_RESIDENCIA RSD
--WHERE CRRSD_MODALIDAD = TMP_MODALIDAD AND
--CISLA_CODIGO = TMP_CISLA_CODIGO AND
--CRRSD_ESTADO;

IF (TMP_MAX_RESIDENCIA IS NULL) THEN
TMP_MAX_RESIDENCIA := 0;
END IF;

IF (TMP_IS_TRANSEUNTE) THEN
--TMP_MAX_RESIDENCIA := (TMP_MAX_RESIDENCIA + 1);
--ELSE

TMP_CRRES_FECHA_EMISION := TMP_CRTRA_FECHA_INGRESO::DATE;
TMP_MAX_RESIDENCIA := NULL;
END IF;

--SELECCIONA LA RESIDENCIA DE LA PERSONA QUE HAYA SIDO DE LA MISMA MODALIDAD DE LA NUEVA RESIDENCIA
SELECT CRRSD_CODIGO, CRRSD_MODALIDAD
INTO TMP_CRRSD_CODIGO, TMP_CRRSD_MODALIDAD
FROM SII.CGG_RES_RESIDENCIA
WHERE CRPER_CODIGO = TMP_CGG_CRPER_CODIGO AND
CRTST_CODIGO IN (WITH RECURSIVE TIPO(CRTST_CODIGO, CGG_CRTST_CODIGO, CRTST_DESCRIPCION)AS(
SELECT CRTST_CODIGO, CGG_CRTST_CODIGO, CRTST_DESCRIPCION FROM CGG_RES_TIPO_SOLICITUD_TRAMITE WHERE (CRTST_CODIGO = (SELECT CGCNF_VALOR_CADENA
FROM CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '03') OR CRTST_CODIGO = (SELECT CGCNF_VALOR_CADENA
FROM CGG_CONFIGURACION
WHERE CGCNF_CODIGO = '04'))
UNION SELECT TST.CRTST_CODIGO, TST.CGG_CRTST_CODIGO, TP.CRTST_DESCRIPCION FROM CGG_RES_TIPO_SOLICITUD_TRAMITE TST, TIPO TP
WHERE TST.CGG_CRTST_CODIGO = TP.CRTST_CODIGO
) SELECT CRTST_CODIGO  FROM TIPO) AND
CRRSD_ESTADO
ORDER BY CRRSD_FECHA_INICIO DESC LIMIT 1;
IF (TMP_CRRSD_CODIGO IS NOT NULL AND NOT TMP_IS_TRANSEUNTE) THEN
	IF(TMP_CRRSD_MODALIDAD = TMP_MODALIDAD)THEN
		SELECT CRRSD_NUMERO, CISLA_CODIGO INTO TMP_CRRSD_NUMERO, TMP_RSD_ISLA
		FROM SII.CGG_RES_RESIDENCIA
		WHERE CRRSD_CODIGO = TMP_CRRSD_CODIGO;
		IF(TMP_CRRSD_NUMERO IS NOT NULL)THEN
			TMP_MAX_RESIDENCIA := TMP_CRRSD_NUMERO;
			TMP_CISLA_CODIGO := TMP_RSD_ISLA;
			SELECT CISLA_INDICE INTO TMP_CISLA_INDICE FROM SII.CGG_ISLA WHERE CISLA_CODIGO = TMP_CISLA_CODIGO;
		END IF;
	END IF;
END IF;

--SELECCIONA LA RESIDENCIA VIGENTE DEL BENEFICIARIO PARA CERRAR
SELECT CRRSD_CODIGO INTO TMP_CRRSD_CODIGO
FROM SII.CGG_RES_RESIDENCIA
WHERE CRPER_CODIGO = TMP_CGG_CRPER_CODIGO AND
CRRSD_VIGENTE AND
CRRSD_ESTADO;
IF (TMP_CRRSD_CODIGO IS NOT NULL AND CURRENT_DATE::DATE >= TMP_CRRES_FECHA_EMISION::DATE) THEN
UPDATE SII.CGG_RES_RESIDENCIA SET CRRSD_VIGENTE = FALSE,
--CRRSD_FECHA_CADUCIDAD = TMP_CRRES_FECHA_EMISION - interval '00:01:00',
CRRSD_USUARIO_UPDATE = IN_USER_NAME,
CRRSD_FECHA_UPDATE = CURRENT_TIMESTAMP
WHERE CRRSD_CODIGO = TMP_CRRSD_CODIGO;
END IF;

--MO: ASIGNACIÓN DE LA FECHA DE INICIO INGRESADA POR USUARIO EXTERNO PARA TEMPORALES

IF (TMP_IS_TEMPORAL AND TMP_CRTRA_FECHA_INGRESO > TMP_CRRES_FECHA_EMISION) THEN
TMP_CRRES_FECHA_EMISION := TMP_CRTRA_FECHA_INGRESO;
END IF;

--CREACION DE LA RESIDENCIA
SELECT SII.F_CGG_RES_RESIDENCIA_INSERT(
'KEYGEN'::VARCHAR,
TMP_CGG_CRPER_CODIGO,
TMP_CRTST_CODIGO,
IN_CRTRA_CODIGO,
NULL::VARCHAR,
TMP_MAX_RESIDENCIA::INTEGER,
TMP_MODALIDAD::SMALLINT,
TMP_CRRES_FECHA_EMISION::TIMESTAMP WITH TIME ZONE,
TMP_CRRSD_FECHA_CADUCIDAD::TIMESTAMP WITH TIME ZONE,
FALSE,
NULL::TIMESTAMP WITH TIME ZONE,
NULL::VARCHAR,
(TMP_CRRSD_CODIGO IS NULL OR CURRENT_DATE::DATE >= COALESCE(TMP_CRRES_FECHA_EMISION::DATE, CURRENT_DATE + 1) ), --VIGENTE
TMP_CRRSD_TRAMITE_PENDIENTE,
TRUE,
IN_USER_NAME
)INTO TMP_NEW_CRRSD_CODIGO;

--ACTUALIZACION DE LA ISLA DE LA RESIDENCIA
UPDATE SII.CGG_RES_RESIDENCIA SET CISLA_CODIGO = TMP_CISLA_CODIGO
WHERE CRRSD_CODIGO = TMP_NEW_CRRSD_CODIGO;

--ACTUALIZACION DEL NUMERO DE RESIDENCIA DE LA PERSONA
IF (NOT TMP_IS_TRANSEUNTE) THEN
UPDATE SII.CGG_RES_PERSONA SET
CRPER_NUMERO_RESIDENCIA = TMP_CISLA_INDICE::VARCHAR||TMP_INDICE::VARCHAR||LPAD(TMP_MAX_RESIDENCIA::VARCHAR,5,'0'),
CRPER_USUARIO_UPDATE = IN_USER_NAME,
CRPER_FECHA_UPDATE = CURRENT_TIMESTAMP
WHERE CRPER_CODIGO = TMP_CGG_CRPER_CODIGO;
UPDATE SII.CGG_RES_RESIDENCIA SET
CRRSD_NUMERO_RESIDENCIA = TMP_CISLA_INDICE::VARCHAR||TMP_INDICE::VARCHAR||LPAD(TMP_MAX_RESIDENCIA::VARCHAR,5,'0'),
CRRSD_USUARIO_UPDATE = IN_USER_NAME,
CRRSD_FECHA_UPDATE = CURRENT_TIMESTAMP
WHERE CRPER_CODIGO = TMP_CGG_CRPER_CODIGO AND CRRSD_CODIGO = TMP_NEW_CRRSD_CODIGO;
END IF;

--CREA UN NUEVO USUARIO PARA EL RESIDENTE PERMANENTE
IF (TMP_IS_PERMANENTE) THEN
SELECT SII.F_CGG_RES_RESIDENCIA_USUARIO(IN_USER_NAME,TMP_CGG_CRPER_CODIGO,IN_CRTRA_CODIGO) INTO TMP_CODIGO;
END IF;


--CREA LOS REGISTRO DE SOPORTE SI LA PERSONA ESTA DENTRO DE LA PROVINCIA Y CAMBIA DE RESIDENCIA
IF (CURRENT_DATE::DATE >= TMP_CRRES_FECHA_EMISION::DATE) THEN
SELECT SII.F_CREAR_REGISTROS_SOPORTE(IN_USER_NAME,
TMP_CGG_CRPER_CODIGO,
TMP_NEW_CRRSD_CODIGO,
TMP_CRRES_FECHA_EMISION,
TMP_CRRSD_FECHA_CADUCIDAD,
IN_CRTRA_CODIGO
) INTO TMP_CODIGO;
END IF;
RETURN 'TRUE';
END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION f_cgg_res_residencia_generar(character varying, character varying, character varying)
  OWNER TO postgres;



CREATE OR REPLACE FUNCTION f_cgg_genera_num_resolucion(
    in_cisla_codigo character varying,
    in_crssc_codigo character varying)
  RETURNS character varying AS
$BODY$
DECLARE
TMP_SECUENCIA INT;
TMP_ANIO INT;
TMP_ACRONIMO CHARACTER VARYING;
TMP_ABBR VARCHAR;
TMP_TPT_ABBR VARCHAR;
TMP_TPT_ABBR_CODIGO VARCHAR;
TMP_CRSSC_CODIGO VARCHAR;
TMP_COUNT INT;
BEGIN
TMP_SECUENCIA := 0;
SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP) INTO TMP_ANIO;
TMP_CRSSC_CODIGO = IN_CRSSC_CODIGO;

SELECT COUNT(*) INTO TMP_COUNT FROM SII.CGG_RES_TRAMITE TRM WHERE TRM.CRTRA_CODIGO = IN_CRSSC_CODIGO;
IF (TMP_COUNT > 0) THEN
SELECT RSL.CRSSC_CODIGO INTO TMP_CRSSC_CODIGO
FROM SII.CGG_RES_TRAMITE TRM
INNER JOIN SII.CGG_RES_RESOL_TRAMITE RST ON RST.CRTRA_CODIGO = TRM.CRTRA_CODIGO AND RST.CRRST_ESTADO
INNER JOIN SII.CGG_RES_RESOLUCION RSL ON RSL.CRRES_CODIGO = RST.CRRES_CODIGO AND RSL.CRRES_ESTADO
WHERE TRM.CRTRA_CODIGO = IN_CRSSC_CODIGO;
END IF;

SELECT CISLA_ABREVIATURA INTO TMP_ABBR FROM SII.CGG_ISLA WHERE CISLA_CODIGO = IN_CISLA_CODIGO;
TMP_TPT_ABBR := 'RSLMISC';

IF (TMP_CRSSC_CODIGO IS NOT NULL AND LENGTH(TMP_CRSSC_CODIGO) > 0) THEN
SELECT CM.CRCOM_ABREVIATURA,CM.CRCOM_ABREVIATURA||EXTRACT(YEAR FROM CURRENT_TIMESTAMP) INTO TMP_TPT_ABBR,TMP_TPT_ABBR_CODIGO
FROM SII.CGG_RES_SESION_COMITE SC
INNER JOIN SII.CGG_RES_COMITE CM ON CM.CRCOM_CODIGO = SC.CRCOM_CODIGO
WHERE SC.CRSSC_CODIGO = TMP_CRSSC_CODIGO;
ELSE
	SELECT 'AUTO','RE' INTO TMP_TPT_ABBR,TMP_TPT_ABBR_CODIGO;
END IF;
SELECT CGSCN_SECUENCIA INTO TMP_SECUENCIA FROM SII.CGG_SECUENCIA WHERE CGSCN_CODIGO = TMP_TPT_ABBR_CODIGO AND CGSCN_ANIO = TMP_ANIO;

IF (TMP_SECUENCIA IS NULL OR TMP_SECUENCIA = 0) THEN
TMP_SECUENCIA := 1;
INSERT INTO SII.CGG_SECUENCIA (CGSCN_CODIGO, CGSCN_SECUENCIA, CGSCN_ANIO) VALUES(TMP_TPT_ABBR_CODIGO, TMP_SECUENCIA, EXTRACT(YEAR FROM CURRENT_TIMESTAMP));
END IF;

UPDATE SII.CGG_SECUENCIA SET CGSCN_SECUENCIA = TMP_SECUENCIA + 1,
CGSCN_ANIO = TMP_ANIO
WHERE CGSCN_CODIGO = TMP_TPT_ABBR_CODIGO;

SELECT CGCNF_VALOR_CADENA INTO TMP_ACRONIMO
FROM SII.CGG_CONFIGURACION WHERE CGCNF_CODIGO = 'CONF8';

  RETURN  LPAD(TMP_SECUENCIA::VARCHAR,4,'0'::VARCHAR)||'-'||TMP_ANIO||'-'||'CGREG-DPCR';
--RETURN  TMP_ACRONIMO||'-'||TMP_ABBR||'-'||TMP_TPT_ABBR||'-'||TMP_ANIO||'-'||LPAD(TMP_SECUENCIA::VARCHAR,4,'0'::VARCHAR);
END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

--> MIGRATION SCRIPT CONTROLLER <--
INSERT INTO sii.cgg_migrationscript (mrgsp_codigo,mrgsp_fecha,mrgsp_usuario_insert,mrgsp_fecha_insert,mrgsp_usuario_update,mrgsp_fecha_update,
	mrgsp_estado,mrgsp_developer,mrgsp_name,mrgsp_description,
	mrgsp_releaseno,mrgsp_filename,mrgsp_isapply)
VALUES(SII.F_KEYGEN('CGG_MIGRATIONSCRIPT','MRGSP_CODIGO','MRGSP'), current_timestamp,'ADMIN', current_timestamp,'ADMIN', current_timestamp,
	true,'acanaveral','Modifica el la Secuencia de las Residencias','Permite seleccionar las secuencias de las residencias desde la tabla CGG_SECUENCIA',
	'2.0','Update/Scripts/1.0-2.0/2016_09_18_SecuenciaResidencias.sql',true);